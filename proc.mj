(* Constants *)

const WORD = 42

(* Utilities *)

signal<n, i>(a:[n]) = s where
    s = a[(n - 1) - i];
end where

replicate<n>(b) = o:[n] where
    if n = 0 then
        o = []
    else
        o = b . replicate<n - 1>(b)
    end if
end where

increment_i<n, i>(a:[n], c_in) = o:[n - i] where
    if i = n then
        o = [];
    else
        ai = a[(n - 1) - i];
        o = increment_i<n, i + 1>(a, ai & c_in) . ai ^ c_in;
    end if
end where

increment<n>(a:[n]) = o:[n] where
    o = increment_i<n, 0>(a, 1);
end where

decrement_i<n, i>(a:[n], c_in) = o:[n - i] where
    if i = n then
        o = [];
    else
        ai = a[(n - 1) - i];
        o = decrement_i<n, i + 1>(a, not(ai) & c_in) . ai ^ c_in;
    end if
end where

decrement<n>(a:[n]) = o:[n] where
    o = decrement_i<n, 0>(a, 1);
end where

addsub_i<n, i>(a:[n], b:[n], sub, c_in) = o:[n - i] where
    if i = n then
        o = [];
    else
        ai = a[(n - 1) - i];
        bi = b[(n - 1) - i] ^ sub;
        x = ai ^ bi;
        o = addsub_i<n, i + 1>(a, b, sub, (ai & bi) + (x & c_in)) . x ^ c_in;
    end if
end where

addsub<n>(a:[n], b:[n], sub) = o:[n] where
    o = addsub_i<n, 0>(a, b, sub, sub);
end where

mul_i<n, i>(a:[n], b:[n]) = o:[n] where
    if i = n then
        o = replicate<n>(0);
    else
        oi1 = mul_i<n, i + 1>(a, b);
        s = addsub<n>(oi1, a[i..] . replicate<i>(0), false);
        o = mux<1, n>(b[i], s, oi1);
    end if
end where

mul<n>(a:[n], b:[n]) = o:[n] where
    o = mul_i<n, 0>(a, b);
end where

divmod_i<n, i>(a:[n], b:[n]) = (q:[n - i], r:[n - i]) where
    if i = n then
        q = [];
        r = [];
    else
        (qi1, ri1) = divmod_i<n, i + 1>(a, b);
        r1 = ri1 . a[(n - 1) - i];
        d = addsub<n>(replicate<i>(0) . r1, b, true);
        l = d[0];
        r = mux<1, n - i>(l, r1, d[i..]);
        q = qi1 . not(l);
    end if
end where

divmod<n>(a:[n], b:[n], mod) = o:[n] where
    (q, r) = divmod_i<n, 0>(a, b);
    o = mux<1, n>(mod, r, q);
end where

(* Processor *)

decode_operand(ins:[WORD]) = (mem, a, b, imm:[WORD]) where
    mem = signal<WORD, 0>(ins);
    r = signal<WORD, 1>(ins);
    a = r & signal<WORD, 2>(ins);
    b = r & signal<WORD, 3>(ins);
    imm = 00 . ins[..WORD - 3];
end where

main() = () where
    (* Constants *)
    zero = replicate<WORD>(0);

    (* Registers *)
    pc_reg = reg(pc);
    a_reg = reg(a);
    b_reg = reg(b);

    (* Flags *)
    flag_zero = mux<WORD, 1>(a_reg, false, true);
    flag_sign = a_reg[0];

    (* Fetch *)
    ins0 = ram<WORD, WORD>(pc_reg, false, zero, zero);
    pc1 = increment<WORD>(pc_reg);
    ins1 = ram<WORD, WORD>(pc1, false, zero, zero);
    pc2 = increment<WORD>(pc1);
    ins2 = ram<WORD, WORD>(pc2, false, zero, zero);
    pc3 = increment<WORD>(pc2);

    (* Decode *)
    signal_mov    = signal<WORD,  0>(ins0);
    signal_addsub = signal<WORD,  1>(ins0);
    signal_sub    = signal<WORD,  2>(ins0);
    signal_inc    = signal<WORD,  3>(ins0);
    signal_dec    = signal<WORD,  4>(ins0);
    signal_mul    = signal<WORD,  5>(ins0);
    signal_divmod = signal<WORD,  6>(ins0);
    signal_mod    = signal<WORD,  7>(ins0);
    signal_jump   = signal<WORD,  8>(ins0);
    signal_zero   = signal<WORD,  9>(ins0);
    signal_less   = signal<WORD, 10>(ins0);

    (op1_mem, op1_a, op1_b, op1_imm) = decode_operand(ins1);
    op1 = mux<1, WORD>(op1_mem, ram_out,
          mux<1, WORD>(op1_a, a_reg,
          mux<1, WORD>(op1_b, b_reg,
          op1_imm)));

    (op2_mem, op2_a, op2_b, op2_imm) = decode_operand(ins2);
    op2 = mux<1, WORD>(op2_a, a_reg,
          mux<1, WORD>(op2_b, b_reg,
          op2_imm));

    (* RAM *)
    ram_out = ram<WORD, WORD>(op1_imm, signal_mov & op2_mem, op2_imm, op1);

    (* ALU *)
    addsub_out = addsub<WORD>(op2, op1, signal_sub);
    mul_out = mul<WORD>(op2, op1);
    divmod_out = divmod<WORD>(op2, op1, signal_mod);
    inc_out = increment<WORD>(op2);
    dec_out = decrement<WORD>(op2);

    (* Bus *)
    bus = mux<1, WORD>(signal_addsub, addsub_out,
          mux<1, WORD>(signal_inc, inc_out,
          mux<1, WORD>(signal_dec, dec_out,
          mux<1, WORD>(signal_mul, mul_out,
          mux<1, WORD>(signal_divmod, divmod_out,
          op1)))));

    (* Update registers *)
    a = mux<1, WORD>(signal_mov & op2_a, bus, a_reg);
    b = mux<1, WORD>(signal_mov & op2_b, bus, b_reg);

    (* Jump *)
    jump = signal_jump & (not(signal_less) + flag_sign)
                       & (not(signal_zero) + flag_zero);
    pc = mux<1, WORD>(jump, op1, pc3);
end where
